# In this code OPF with reconfiguration using big M relaxation is implemented
include("Clear_fnc.jl")
clearconsole()

using JuMP
using GLPK

# Define the sets and parameters
G = 1:3                  # Set of generators
B = 1:4                  # Set of buses
L = [(1, 2), (2, 3), (3, 4)]  # Set of transmission lines (i, j)
Line_state = [1, 1, 1]
# Cost coefficients for each generator (quadratic costs for simplicity)
c_g = Dict(1 => 10.0, 2 => 12.0, 3 => 15.0)

# Generation limits (MW)
P_g_min = Dict(1 => 0.0, 2 => 0.0, 3 => 0.0)     # Minimum generation
P_g_max = Dict(1 => 50.0, 2 => 60.0, 3 => 40.0)  # Maximum generation

# Demand at each bus (MW)
P_d = Dict(1 => 0.0, 2 => 30.0, 3 => 20.0, 4 => 10.0)

# Line parameters
P_ij_min = Dict((1, 2) => -40.0, (2, 3) => -50.0, (3, 4) => -30.0)  # Min line flows
P_ij_max = Dict((1, 2) => 40.0, (2, 3) => 50.0, (3, 4) => 30.0)     # Max line flows
b_ij = Dict((1, 2) => 0.01, (2, 3) => 0.015, (3, 4) => 0.02)        # Line susceptances

# Big-M constant for switching constraints (ensure it's large enough to cover potential flow ranges)
M = 1000.0

# Create the optimization model
model = Model(GLPK.Optimizer)

# Decision variables
@variable(model, P_g[g in G] >= 0)                      # Power generated by each generator
@variable(model, θ[b in B])                             # Voltage angle at each bus
@variable(model, P_ij[(i, j) in L])                     # Power flow on each line
@variable(model, z[(i, j) in L], Bin, start = Line_state)                   # Binary variable indicating line status (0: off, 1: on)

# Objective: Minimize the total generation cost
@objective(model, Min, sum(c_g[g] * P_g[g] for g in G))

# Nodal power balance constraints
for i in B
    @constraint(model, sum(P_g[g] for g in G if g in i) - sum(P_d[d] for d in i if d in B) ==
                        sum(P_ij[(i, j)] for (i, j) in L if i == i) -
                        sum(P_ij[(j, i)] for (j, i) in L if j == i))
end

# Generation limits
for g in G
    @constraint(model, P_g_min[g] <= P_g[g] <= P_g_max[g])
end

# Transmission line limits with switching
for (i, j) in L
    @constraint(model, P_ij_min[(i, j)] * z[(i, j)] <= P_ij[(i, j)] <= P_ij_max[(i, j)] * z[(i, j)])
end

# DC power flow equations with switching
for (i, j) in L
    @constraint(model, P_ij[(i, j)] == -b_ij[(i, j)] * (θ[i] - θ[j]) * z[(i, j)])
end

# Solve the model
optimize!(model)

# Check the solution status and print results
if termination_status(model) == MOI.OPTIMAL
    println("Optimal solution found!")
    println("Objective Value: ", objective_value(model))
    println("Generation Output: ", value.(P_g))
    println("Voltage Angles: ", value.(θ))
    println("Line Flows: ", value.(P_ij))
    println("Line Status: ", value.(z))
else
    println("The model did not find an optimal solution.")
end
