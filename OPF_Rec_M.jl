# In this code OPF with reconfiguration using big M relaxation is implemented
include("Clear_fnc.jl")
clearconsole()

using JuMP
using Gurobi

# Define the sets and parameters
G = 1:3                  # Set of generators
B = 1:4                  # Set of buses
L = [(1, 2), (2, 3), (3, 4)]  # Set of transmission lines (i, j)
Line_state = [1, 1, 1]
start_values = Dict(L[i] => Line_state[i] for i in 1:size(L,1))
# Cost coefficients for each generator (quadratic costs for simplicity)
c_g = Dict(1 => 10.0, 2 => 12.0, 3 => 15.0)

# Generation limits (MW)
P_g_min = Dict(1 => 0.0, 2 => 0.0, 3 => 0.0)     # Minimum generation
P_g_max = Dict(1 => 50.0, 2 => 60.0, 3 => 40.0)  # Maximum generation

# Demand at each bus (MW)
P_d = Dict(1 => 0.0, 2 => 30.0, 3 => 20.0, 4 => 10.0)

# Line parameters
P_ij_min = Dict((1, 2) => -40.0, (2, 3) => -50.0, (3, 4) => -30.0)  # Min line flows
P_ij_max = Dict((1, 2) => 40.0, (2, 3) => 50.0, (3, 4) => 30.0)     # Max line flows
b_ij = Dict((1, 2) => 0.01, (2, 3) => 0.015, (3, 4) => 0.02)        # Line susceptances

# Big-M constant for switching constraints (ensure it's large enough to cover potential flow ranges)
BIG_M = 1000000.0
M = 1000.0
# Create the optimization model
model = Model(Gurobi.Optimizer)

# Decision variables
@variable(model, P_g[g in G] >= 0)              # Power generated by each generator
@variable(model, z0[g in G], Bin, start = 0)    # Binary variable indicating whether P_g[g] > 0
@variable(model, θ[b in B])                     # Voltage angle at each bus
@variable(model, P_ij[(i, j) in L])             # Power flow on each line
@variable(model, z[(i, j) in L], Bin, start = start_values[(i, j)])   # Binary variable indicating line status (0: off, 1: on)
@variable(model, f[(i, j) in L])                # Auxiliary variable for linearizing the flow constraint
# Objective: Minimize the total generation cost
@objective(model, Min, sum(c_g[g] * P_g[g] for g in G))

# Nodal power balance constraints
for i in B
    @constraint(model, sum(P_g[g] for g in G if g in i) - sum(P_d[d] for d in i if d in B) ==
                        sum(P_ij[(i, j)] for (i, j) in L if i == i) -
                        sum(P_ij[(j, i)] for (j, i) in L if j == i))
end

# Generation limits
for g in G
    # Constraint to ensure P_g[g] is within range if z0[g] = 1
    @constraint(model, P_g_min[g] * z0[g] <= P_g[g])
    @constraint(model, P_g[g] <= P_g_max[g] * z0[g])
    
    # Ensure z0[g] is 1 if P_g[g] is positive, using the Big-M method
    @constraint(model, P_g[g] <= M * z0[g])
end

# Transmission line limits with switching (reformulated)
for (i, j) in L
    # Lower bound constraint
    @constraint(model, P_ij[(i, j)] >= P_ij_min[(i, j)] * z[(i, j)])
    # Upper bound constraint
    @constraint(model, P_ij[(i, j)] <= P_ij_max[(i, j)] * z[(i, j)])
end

# Linearization of DC power flow equations with switching using auxiliary variable
for (i, j) in L
    @constraint(model, f[(i, j)] == -b_ij[(i, j)] * (θ[i] - θ[j])*10e3)  # Linear relation between angles and flow
    @constraint(model, P_ij[(i, j)] <= f[(i, j)] + BIG_M * (1 - z[(i, j)]))
    @constraint(model, P_ij[(i, j)] >= f[(i, j)] - BIG_M * (1 - z[(i, j)]))
    @constraint(model, P_ij[(i, j)] <= BIG_M * z[(i, j)])  # Enforces P_ij = 0 when z = 0
    @constraint(model, P_ij[(i, j)] >= -BIG_M * z[(i, j)])
end

# Solve the model
optimize!(model)

# Check the solution status and print results
if termination_status(model) == MOI.OPTIMAL
    println("Optimal solution found!")
    println("Objective Value: ", objective_value(model))
    println("Generation Output: ", value.(P_g))
    println("Voltage Angles: ", value.(θ))
    println("Line Flows: ", value.(P_ij))
    println("Line Status: ", value.(z))
else
    println("The model did not find an optimal solution.")
end
