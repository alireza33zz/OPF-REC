# In this code OPF with reconfiguration using big M relaxation is implemented
include("Clear_fnc.jl")
clearconsole()

using JuMP
using Gurobi
using Statistics
using Crayons

# Define the sets and parameters
G = 1:3                  # Set of generators
B = 1:4                  # Set of buses
L = [(1, 2), (2, 3), (3, 4)]  # Set of transmission lines (i, j)
Line_state = [1, 1, 1]
start_values = Dict(L[i] => Line_state[i] for i in 1:size(L,1))
# Cost coefficients for each generator (quadratic costs for simplicity)
c_g = Dict(1 => 20.0, 2 => 25.0, 3 => 30.0)

# Generation limits (MW)
P_g_min = Dict(1 => 8, 2 => 8, 3 => 8)  # Minimum generation limits
P_g_max = Dict(1 => 50.0, 2 => 60.0, 3 => 40.0)  # Maximum generation limits

# Demand at each bus (MW)
P_d = Dict(1 => 0.0, 2 => 40.0, 3 => 20.0, 4 => 30.0)  # Power demand at each bus
Line_bias = mean([P_d[b] for b in B])

# Line parameters
b_ij = Dict((1, 2) => 0.1, (2, 3) => 0.15, (3, 4) => 0.1)  # Susceptance of each line
P_ij_min = Dict((1, 2) => -50.0, (2, 3) => -45.0, (3, 4) => -40.0)  # Min power flow limits
P_ij_max = Dict((1, 2) => 50.0, (2, 3) => 45.0, (3, 4) => 40.0)  # Max power flow limits

# Big-M constant for switching constraints (ensure it's large enough to cover potential flow ranges)
BIG_M = 1000000.0
M = 1000.0
# Create the optimization model
model = Model(Gurobi.Optimizer)

# Decision variables
@variable(model, P_g[g in G] >= 0)              # Power generated by each generator
@variable(model, z0[g in G], Bin, start = 0)    # Binary variable indicating whether P_g[g] > 0
@variable(model, θ[b in B], start = 0)                     # Voltage angle at each bus
@variable(model, P_ij[l in L], start = Line_bias)      # Power flow on each line
@variable(model, z[(i, j) in L], Bin, start = start_values[(i, j)])   # Binary variable indicating line status (0: off, 1: on)
@variable(model, f[(i, j) in L])                # Auxiliary variable for linearizing the flow constraint
# Objective: Minimize the total generation cost
@objective(model, Min, sum(c_g[g] * P_g[g] for g in G))

# Nodal power balance constraints
@constraint(
    model,
    [i in B],
    sum(P_g[g] for g in G if g == i) - P_d[i] == sum(P_ij[l] for l in L if l[1] == i) - sum(P_ij[l] for l in L if l[2] == i)
)

# Generation limits
for g in G
    # Constraint to ensure P_g[g] is within range if z0[g] = 1
    @constraint(model, P_g_min[g] * z0[g] <= P_g[g])
    @constraint(model, P_g[g] <= P_g_max[g] * z0[g])
    
    # Ensure z0[g] is 1 if P_g[g] is positive, using the Big-M method
    @constraint(model, P_g[g] <= M * z0[g])
end

# Transmission line limits with switching (reformulated)
for (i, j) in L
    # Lower bound constraint
    @constraint(model, P_ij[(i, j)] >= P_ij_min[(i, j)] * z[(i, j)])
    # Upper bound constraint
    @constraint(model, P_ij[(i, j)] <= P_ij_max[(i, j)] * z[(i, j)])
end

# Linearization of DC power flow equations with switching using auxiliary variable
for (i, j) in L
    @constraint(model, f[(i, j)] == -b_ij[(i, j)] * (θ[i] - θ[j])*10e3)  # Linear relation between angles and flow
    @constraint(model, P_ij[(i, j)] <= f[(i, j)] + BIG_M * (1 - z[(i, j)]))
    @constraint(model, P_ij[(i, j)] >= f[(i, j)] - BIG_M * (1 - z[(i, j)]))
    @constraint(model, P_ij[(i, j)] <= BIG_M * z[(i, j)])  # Enforces P_ij = 0 when z = 0
    @constraint(model, P_ij[(i, j)] >= -BIG_M * z[(i, j)])
end

# Set reference angle to zero (to avoid singularities)
@constraint(model, θ[1] == 0)

# Solve the model
optimize!(model)
 

# Define Crayons for styling text
bold_green = Crayon(foreground = :green, bold = true)
bold_red = Crayon(foreground = :red, bold = true)

# Check the solution status and print results
if termination_status(model) == MOI.OPTIMAL
    println(bold_green("Optimal solution found!"))
    println("Objective Value:\n", objective_value(model))
    println("Generation Output:\n", join(value.(P_g), "\n"))
    println("Voltage Angles:\n", join(value.(θ), "\n"))
    println("Line Flows:\n", join(value.(P_ij), "\n"))
    println("Line Status:\n", join(value.(z), "\n"))
else
    println(bold_red("The model did not find an optimal solution."))
    # Use the IIS (Irreducible Infeasible Subsystem) to debug infeasibility
    println("Identifying infeasibility...")
    compute_conflict!(model)
    conflict_summary(model)
end


