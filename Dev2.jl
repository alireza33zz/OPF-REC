# In this code OPF with reconfiguration using big M relaxation is implemented
include("Clear_fnc.jl")
clearconsole()

using CSV
using Crayons
using DataFrames
using Gurobi
using JuMP

# Define sets of Generators and Buses
G = [1,4]  # Set of generators
B = 1:6  # Set of buses
# Define sets of transmission lines
NL = [(1, 2), (2, 5), (3, 4), (3, 6)]  # Set of normal transmission lines
SL = [(2, 3)]  # Set of transmission lines with switches
L = vcat(NL, SL)  # Set of all transmission lines

# Lines and Switches status
Line_state = vcat(ones(length(NL)), zeros(length(SL)))  # Use length instead of size

# Create a dictionary to map lines to their states
start_values = Dict(L[i] => Line_state[i] for i in 1:length(L))


# Power base unit is kW
# Cost coefficients for each generator (linear costs for simplicity)
c_g = Dict(1 => 20.0, 4 => 5.0)

# Generation limits (kW)
P_g_min = Dict(1 => 8, 4 => 8)  # Minimum generation limits
P_g_max = Dict(1 => 120.0, 4 => 120.0)  # Maximum generation limits

# Demand at each bus (kW)
P_d = Dict(1 => 0.0, 2 => 40.0, 3 => 20.0, 4 => 0.0, 5 => 30.0, 6 => 30.0)  # Power demand at each bus

# Line parameters
b_ij = Dict((1, 2) => 0.1, (2, 3) => 0.15, (2,5) => 0.1, (3, 4) => 0.1, (3, 6) => 0.1)  # Susceptance of each line
P_ij_min = Dict((1, 2) => -80.0, (2, 3) => -65.0, (2,5) => -40, (3, 4) => -130.0, (3, 6) => -40)  # Min power flow limits
P_ij_max = Dict((1, 2) => 80.0, (2, 3) => 65.0, (2,5) => 40, (3, 4) => 130.0, (3, 6) => 40)  # Max power flow limits

# Big-M constant for switching constraints (ensure it's large enough to cover potential flow ranges)
BIG_M = 1000000.0
M = 1000.0
# Create the optimization model
model = Model(Gurobi.Optimizer)

# Decision variables
@variable(model, P_g[g in G] >= 0)              # Power generated by each generator
@variable(model, z0[g in G], Bin, start = 0)    # Binary variable indicating whether P_g[g] > 0
@variable(model, θ[b in B], start = 0)                     # Voltage angle at each bus
@variable(model, P_ij[l in L], start = 0)      # Power flow on each line
@variable(model, z[(i, j) in L], Bin, start = start_values[(i, j)])   # Binary variable indicating line status (0: off, 1: on)
@variable(model, f[(i, j) in L])                # Auxiliary variable for linearizing the flow constraint
# Objective: Minimize the total generation cost
@objective(model, Min, sum(c_g[g] * P_g[g] for g in G))

# Set reference angle to zero (to avoid singularities)
@constraint(model, θ[1] == 0)

# Set normal lines as an always closed switch line
for (i, j) in NL
    @constraint(model, z[(i, j)] == 1)
end

# Nodal power balance constraints
@constraint(
    model,
    [i in B],
    sum(P_g[g] for g in G if g == i) - P_d[i] == sum(P_ij[l] for l in L if l[1] == i) - sum(P_ij[l] for l in L if l[2] == i)
)

# Generation limits
for g in G
    # Constraint to ensure P_g[g] is within range if z0[g] = 1
    @constraint(model, P_g_min[g] * z0[g] <= P_g[g])
    @constraint(model, P_g[g] <= P_g_max[g] * z0[g])
    
    # Ensure z0[g] is 1 if P_g[g] is positive, using the Big-M method
    @constraint(model, P_g[g] <= M * z0[g])
end

# Transmission line limits with switching (reformulated)
for (i, j) in L
    # Lower bound constraint
    @constraint(model, P_ij[(i, j)] >= P_ij_min[(i, j)] * z[(i, j)])
    # Upper bound constraint
    @constraint(model, P_ij[(i, j)] <= P_ij_max[(i, j)] * z[(i, j)])
end

# Linearization of DC power flow equations with switching using auxiliary variable
for (i, j) in L
    @constraint(model, f[(i, j)] == -b_ij[(i, j)] * (θ[i] - θ[j])*10e3)  # Linear relation between angles and flow
    @constraint(model, P_ij[(i, j)] <= f[(i, j)] + BIG_M * (1 - z[(i, j)]))
    @constraint(model, P_ij[(i, j)] >= f[(i, j)] - BIG_M * (1 - z[(i, j)]))
    @constraint(model, P_ij[(i, j)] <= BIG_M * z[(i, j)])  # Enforces P_ij = 0 when z = 0
    @constraint(model, P_ij[(i, j)] >= -BIG_M * z[(i, j)])
end



# Solve the model
optimize!(model)
 

# Define Crayons for styling text
bold_green = Crayon(foreground = :green, bold = true)
bold_red = Crayon(foreground = :red, bold = true)

# Check the solution status and print results
if termination_status(model) == MOI.OPTIMAL
    println(bold_green("Optimal solution found!"))
    println("Objective Value:\n", objective_value(model))
    println("Generation Output:\n", join(value.(P_g), "\n"))
    println("Voltage Angles:\n", join(value.(θ), "\n"))
    println("Line Flows:\n", join(value.(P_ij), "\n"))
    println("Line Status:\n", join(value.(z), "\n"))
else
    println(bold_red("The model did not find an optimal solution."))
    # Use the IIS (Irreducible Infeasible Subsystem) to debug infeasibility
    println("Identifying infeasibility...")
    compute_conflict!(model)
    conflict_summary(model)
end

# Create a DataFrame to store the results
results = DataFrame()

# Check the solution status and print results
if termination_status(model) == MOI.OPTIMAL
    results[!, :Status] = ["Optimal solution found!"]
    results[!, :ObjectiveValue] = [objective_value(model)]
    results[!, :GenerationOutput] = [join(value.(P_g))]
    results[!, :VoltageAngles] = [join(value.(θ))]
    results[!, :LineFlows] = [join(value.(P_ij))]
    results[!, :LineStatus] = [join(value.(z))]
else
    results[!, :Status] = ["The model did not find an optimal solution."]
    results[!, :ObjectiveValue] = [NaN]
    results[!, :GenerationOutput] = [NaN]
    results[!, :VoltageAngles] = [NaN]
    results[!, :LineFlows] = [NaN]
    results[!, :LineStatus] = [NaN]
    
    # Use the IIS (Irreducible Infeasible Subsystem) to debug infeasibility
    println("Identifying infeasibility...")
    compute_conflict!(model)
    conflict_summary(model)
end

# Save the results to a CSV file
CSV.write("optimization_results_Scen3.csv", results)


